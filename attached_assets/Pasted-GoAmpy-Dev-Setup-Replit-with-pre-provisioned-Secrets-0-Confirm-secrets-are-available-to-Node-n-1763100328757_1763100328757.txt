GoAmpy – Dev Setup (Replit) with pre‑provisioned Secrets
0) Confirm secrets are available to Node (no .env files needed)

RUN IN SHELL (repo root):

# Show which required secrets are set (no values printed)
node -e "const ks=['SUPABASE_URL','SUPABASE_ANON_KEY','SUPABASE_SERVICE_ROLE_KEY','DATABASE_URL'];console.log(Object.fromEntries(ks.map(k=>[k,process.env[k]?'[set]':'[missing]'])))"

# Sanity‑print DATABASE_URL host/port/SSL (masked)
node -e "const u=new URL(process.env.DATABASE_URL||'');console.log({host:u.hostname,port:u.port||'default',ssl:u.searchParams.get('sslmode')});"

# Quick DNS resolution check for the DB host
node -e "const dns=require('dns');const u=new URL(process.env.DATABASE_URL||'');dns.lookup(u.hostname,(e,a)=>console.log('dns',e?e.code:a));"


Expected: Keys show [set], host like db.<project-ref>.supabase.co, ssl: 'require' (or ?sslmode=require), and a DNS IP (IPv4 or IPv6).

Don’t add or commit a .env; Replit Secrets already inject process.env for Node.

1) Single dev command & clean start
# Stop any stragglers
pkill -f "tsx watch" || true
pkill -f "vite" || true

# One command to run both apps
node -e "const fs=require('fs');const p=fs.existsSync('package.json')?JSON.parse(fs.readFileSync('package.json','utf8')):{};p.name='goampy';p.private=true;p.workspaces=['client','server'];p.scripts={dev:'concurrently -k -n server,client -c magenta,cyan \"npm --workspace server run dev\" \"npm --workspace client run dev\"',build:'npm --workspace client run build && npm --workspace server run build'};fs.writeFileSync('package.json',JSON.stringify(p,null,2));console.log('root workspaces ready');"

npm i -D concurrently
npm install


Set Replit Run to: npm run dev (from root). Do not start the server separately inside /server—that causes EADDRINUSE.

2) Client (Vite) — dev port + proxy to BFF
mkdir -p client/src
cat > client/vite.config.ts <<'TS'
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    port: 5176,
    proxy: {
      '/api': 'http://localhost:5177',
      '/r':   'http://localhost:5177'
    }
  }
});
TS


This keeps the split Chat (left) / Console (right) shell consistent with the HTML spec across Landing, Tour, and Dashboard.

3) Server (Express BFF) — pinned to 5177
mkdir -p server/src/{routes,shared,lib}
npm --workspace server i express cors helmet zod dotenv
npm --workspace server i -D typescript tsx @types/node @types/express @types/cors


server/src/index.ts

cat > server/src/index.ts <<'TS'
import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import waitlist from './routes/waitlist.js';
import events from './routes/events.js';

const app = express();
app.use(helmet({ contentSecurityPolicy: false }));
app.use(cors());
app.use(express.json());

// Health
app.get('/api/health', (_req, res) => res.json({ ok: true }));

// APIs
app.use('/api/waitlist', waitlist);
app.use('/api/events', events);

// Referral redirect (click logging can be added later)
app.get('/r/:code', (req, res) => {
  res.redirect(`/?ref=${encodeURIComponent(req.params.code)}`);
});

const port = Number(process.env.BFF_PORT || 5177);
app.listen(port, () => console.log(`BFF on :${port}`));
TS


Ensure server dev script uses 5177

node -e "const fs=require('fs');const p=require('./server/package.json');p.scripts=p.scripts||{};p.scripts.dev='BFF_PORT=5177 tsx watch src/index.ts';fs.writeFileSync('./server/package.json',JSON.stringify(p,null,2));console.log('server dev -> :5177');"

4) Database (Drizzle + Supabase) — uses Secrets from env

Schema — server/src/shared/schema.ts

cat > server/src/shared/schema.ts <<'TS'
import { pgTable, uuid, text, timestamp, jsonb, uniqueIndex } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
  id: uuid('id').primaryKey().defaultRandom(),
  email: text('email').notNull(),
  name: text('name'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
}, (t) => ({ ux_email: uniqueIndex('ux_users_email').on(t.email) }));

export const waitlistEntries = pgTable('waitlist_entries', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(),
  source: text('source').$type<'direct'|'referral'|'campaign'>().default('direct'),
  referrerUserId: uuid('referrer_user_id'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
}, (t) => ({ ux_user: uniqueIndex('ux_waitlist_user').on(t.userId) }));

export const referralCodes = pgTable('referral_codes', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id').notNull(),
  code: text('code').notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
}, (t) => ({
  ux_user: uniqueIndex('ux_referral_user').on(t.userId),
  ux_code: uniqueIndex('ux_referral_code').on(t.code)
}));

export const referralEvents = pgTable('referral_events', {
  id: uuid('id').primaryKey().defaultRandom(),
  referralCodeId: uuid('referral_code_id').notNull(),
  type: text('type').$type<'click'|'signup'>().notNull(),
  email: text('email'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
});

export const events = pgTable('events', {
  id: uuid('id').primaryKey().defaultRandom(),
  userId: uuid('user_id'),
  eventName: text('event_name').notNull(),
  payload: jsonb('payload'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
});
TS


DB client — server/src/lib/db.ts

npm --workspace server i drizzle-orm drizzle-kit postgres
cat > server/src/lib/db.ts <<'TS'
import postgres from 'postgres';
import { drizzle } from 'drizzle-orm/postgres-js';
import * as schema from '../shared/schema.js';

const client = postgres(process.env.DATABASE_URL!, {
  ssl: 'require',
  max: 1,
  // If you switch to Supabase Pooler (port 6543), uncomment:
  // prepare: false,
});
export const db = drizzle(client, { schema });
TS


Drizzle config (CommonJS) — server/drizzle.config.cjs
(Reads process.env.DATABASE_URL directly from Replit Secrets; no local .env required.)

cat > server/drizzle.config.cjs <<'CJS'
require('dotenv').config(); // harmless if no .env present
const path = require('path');
module.exports = {
  schema: path.join(__dirname, 'src', 'shared', 'schema.ts'),
  out: path.join(__dirname, 'drizzle'),
  dialect: 'postgresql',
  dbCredentials: { url: process.env.DATABASE_URL }
};
CJS


Add Drizzle scripts

node -e "const fs=require('fs');const p=require('./server/package.json');p.scripts=p.scripts||{};p.scripts['db:gen']='drizzle-kit generate --config=drizzle.config.cjs';p.scripts['db:push']='drizzle-kit push --config=drizzle.config.cjs';fs.writeFileSync('./server/package.json',JSON.stringify(p,null,2));console.log('drizzle scripts set');"

5) Join API (and Events API)

server/src/routes/waitlist.ts

cat > server/src/routes/waitlist.ts <<'TS'
import { Router } from 'express';
import { z } from 'zod';
import { db } from '../lib/db.js';
import { users, waitlistEntries, referralCodes, events } from '../shared/schema.js';
import { eq } from 'drizzle-orm';

const r = Router();
const Body = z.object({ name: z.string().min(2), email: z.string().email(), ref: z.string().optional().nullable() });
const baseCode = (s:string)=> (s.split('@')[0] || 'user').toLowerCase().replace(/[^a-z0-9]+/g,'').slice(0,12) || 'user';

r.post('/join', async (req, res) => {
  const { name, email, ref } = Body.parse(req.body);

  // Upsert user by email
  let [u] = await db.select().from(users).where(eq(users.email, email));
  if (!u) {
    try { [u] = await db.insert(users).values({ email, name }).returning(); }
    catch { [u] = await db.select().from(users).where(eq(users.email, email)); }
  }

  // Ensure waitlist entry
  const [wl] = await db.select().from(waitlistEntries).where(eq(waitlistEntries.userId, u.id));
  if (!wl) { try { await db.insert(waitlistEntries).values({ userId: u.id, source: ref ? 'referral' : 'direct' }); } catch {} }

  // Ensure referral code (handle collisions)
  const [rc0] = await db.select().from(referralCodes).where(eq(referralCodes.userId, u.id));
  let code = rc0?.code;
  if (!code) {
    let candidate = baseCode(email);
    for (let i = 0; i < 5; i++) {
      try { code = (await db.insert(referralCodes).values({ userId: u.id, code: candidate }).returning())[0].code; break; }
      catch { candidate = `${baseCode(email)}${Math.floor(Math.random()*1000).toString().padStart(3,'0')}`; }
    }
    if (!code) code = (await db.insert(referralCodes).values({ userId: u.id, code: Math.random().toString(36).slice(2,8) }).returning())[0].code;
  }

  await db.insert(events).values({ userId: u.id, eventName: 'onboarding_completed', payload: { ref: ref ?? null } });
  res.json({ referralLink: `/r/${code}` });
});

export default r;
TS


server/src/routes/events.ts

cat > server/src/routes/events.ts <<'TS'
import { Router } from 'express';
import { db } from '../lib/db.js';
import { events } from '../shared/schema.js';

const r = Router();
r.post('/', async (req, res) => {
  const { event, payload, userId } = req.body ?? {};
  if (!event) return res.status(400).json({ error: 'event required' });
  await db.insert(events).values({ eventName: String(event), payload: payload ?? null, userId: userId ?? null });
  res.status(204).end();
});
export default r;
TS


(Optional now, or add later: log a referral_events.click in /r/:code before redirect.)

6) Migrations — using the Secrets already present
# Quiet CLI
pkill -f "tsx watch" || true
pkill -f "vite" || true

# Generate (idempotent)
npm --workspace server run db:gen

# Push (try IPv4 first, then IPv6)
NODE_OPTIONS=--dns-result-order=ipv4first npm --workspace server run db:push \
 || NODE_OPTIONS=--dns-result-order=ipv6first npm --workspace server run db:push


If push still fails with DNS on Replit:

Switch DATABASE_URL (in Replit Secrets) to the Pooling URI (Supabase → Settings → Database → Connection pooling, port 6543), then re‑run push.

If you keep Pooler for runtime, set prepare:false in server/src/lib/db.ts.

Guaranteed fallback: open server/drizzle/0000_*.sql in Supabase SQL Editor and run once.

7) Start & smoke tests
npm run dev


Expect logs

[server] BFF on :5177

[client] Local: http://localhost:5176/

Verify from the browser / shell:

# Health
curl -i http://localhost:5177/api/health

# Join (returns {"referralLink":"/r/<code>"})
curl -i -X POST http://localhost:5177/api/waitlist/join \
  -H 'content-type: application/json' \
  -d '{"name":"Ada","email":"ada@example.com"}'


Now open the Vite URL (5176). In the right Mission Control panel, submit name+email → you should receive a referral link like /r/abc123. Opening it should redirect to /?ref=abc123. This aligns with your split UX across Landing/Tour/Dashboard.

Definition of Done (for this slice)

 One command (npm run dev) starts both processes—no port collisions.

 Secrets are read from Replit (no .env committed).

 GET /api/health → { ok: true }.

 POST /api/waitlist/join → { referralLink: "/r/<code>" }.

 Opening /r/<code> redirects to /?ref=<code>.

 Supabase has tables: users, waitlist_entries, referral_codes, referral_events, events.

Troubleshooting quickies (with pre‑provisioned Secrets)

cat is not defined on Vite start → you pasted a heredoc into a TS file. Recreate client/vite.config.ts exactly as above.

EADDRINUSE :5177 → two servers running. pkill -f "tsx watch"; only use npm run dev at root.

Drizzle “No schema files found” → ensure server/drizzle.config.cjs exists and uses absolute paths; run from root with --config=....

DNS ENOTFOUND on push → try NODE_OPTIONS=--dns-result-order=ipv4first; if still flaky, use Supabase Pooling URI (6543) and set prepare:false, or run the SQL in Supabase once.